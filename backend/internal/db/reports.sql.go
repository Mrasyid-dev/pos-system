// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reports.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const salesByDate = `-- name: SalesByDate :many
SELECT 
  DATE(s.created_at) as sale_date,
  COUNT(*) as total_transactions,
  COALESCE(SUM(s.total_amount), 0) as total_revenue
FROM sales s
WHERE s.created_at >= $1 AND s.created_at <= $2
GROUP BY DATE(s.created_at)
ORDER BY sale_date DESC
`

type SalesByDateParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type SalesByDateRow struct {
	SaleDate          pgtype.Date `json:"sale_date"`
	TotalTransactions int64       `json:"total_transactions"`
	TotalRevenue      interface{} `json:"total_revenue"`
}

func (q *Queries) SalesByDate(ctx context.Context, arg SalesByDateParams) ([]SalesByDateRow, error) {
	rows, err := q.db.Query(ctx, salesByDate, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SalesByDateRow{}
	for rows.Next() {
		var i SalesByDateRow
		if err := rows.Scan(&i.SaleDate, &i.TotalTransactions, &i.TotalRevenue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const salesByPaymentMethod = `-- name: SalesByPaymentMethod :many
SELECT 
  payment_method,
  COUNT(*) as transaction_count,
  COALESCE(SUM(total_amount), 0) as total_amount
FROM sales
WHERE created_at >= $1 AND created_at <= $2
GROUP BY payment_method
ORDER BY total_amount DESC
`

type SalesByPaymentMethodParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type SalesByPaymentMethodRow struct {
	PaymentMethod    pgtype.Text `json:"payment_method"`
	TransactionCount int64       `json:"transaction_count"`
	TotalAmount      interface{} `json:"total_amount"`
}

func (q *Queries) SalesByPaymentMethod(ctx context.Context, arg SalesByPaymentMethodParams) ([]SalesByPaymentMethodRow, error) {
	rows, err := q.db.Query(ctx, salesByPaymentMethod, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SalesByPaymentMethodRow{}
	for rows.Next() {
		var i SalesByPaymentMethodRow
		if err := rows.Scan(&i.PaymentMethod, &i.TransactionCount, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const topProducts = `-- name: TopProducts :many
SELECT 
  p.id,
  p.name,
  p.sku,
  SUM(si.qty) as total_qty_sold,
  COALESCE(SUM(si.subtotal), 0) as total_revenue
FROM sale_items si
JOIN products p ON si.product_id = p.id
JOIN sales s ON si.sale_id = s.id
WHERE s.created_at >= $1 AND s.created_at <= $2
GROUP BY p.id, p.name, p.sku
ORDER BY total_qty_sold DESC
LIMIT $3
`

type TopProductsParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
	Limit       int32              `json:"limit"`
}

type TopProductsRow struct {
	ID           int32       `json:"id"`
	Name         string      `json:"name"`
	Sku          pgtype.Text `json:"sku"`
	TotalQtySold int64       `json:"total_qty_sold"`
	TotalRevenue interface{} `json:"total_revenue"`
}

func (q *Queries) TopProducts(ctx context.Context, arg TopProductsParams) ([]TopProductsRow, error) {
	rows, err := q.db.Query(ctx, topProducts, arg.CreatedAt, arg.CreatedAt_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TopProductsRow{}
	for rows.Next() {
		var i TopProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Sku,
			&i.TotalQtySold,
			&i.TotalRevenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
