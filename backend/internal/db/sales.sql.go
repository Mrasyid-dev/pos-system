// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sales.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSale = `-- name: CreateSale :one
INSERT INTO sales (invoice_no, user_id, total_amount, paid_amount, change_amount, payment_method)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, invoice_no, user_id, total_amount, paid_amount, change_amount, payment_method, created_at
`

type CreateSaleParams struct {
	InvoiceNo     string         `json:"invoice_no"`
	UserID        pgtype.Int4    `json:"user_id"`
	TotalAmount   pgtype.Numeric `json:"total_amount"`
	PaidAmount    pgtype.Numeric `json:"paid_amount"`
	ChangeAmount  pgtype.Numeric `json:"change_amount"`
	PaymentMethod pgtype.Text    `json:"payment_method"`
}

func (q *Queries) CreateSale(ctx context.Context, arg CreateSaleParams) (Sale, error) {
	row := q.db.QueryRow(ctx, createSale,
		arg.InvoiceNo,
		arg.UserID,
		arg.TotalAmount,
		arg.PaidAmount,
		arg.ChangeAmount,
		arg.PaymentMethod,
	)
	var i Sale
	err := row.Scan(
		&i.ID,
		&i.InvoiceNo,
		&i.UserID,
		&i.TotalAmount,
		&i.PaidAmount,
		&i.ChangeAmount,
		&i.PaymentMethod,
		&i.CreatedAt,
	)
	return i, err
}

const getSaleByID = `-- name: GetSaleByID :one
SELECT s.id, s.invoice_no, s.user_id, s.total_amount, s.paid_amount, s.change_amount, s.payment_method, s.created_at, u.username as cashier_name
FROM sales s
LEFT JOIN users u ON s.user_id = u.id
WHERE s.id = $1 LIMIT 1
`

type GetSaleByIDRow struct {
	ID            int32              `json:"id"`
	InvoiceNo     string             `json:"invoice_no"`
	UserID        pgtype.Int4        `json:"user_id"`
	TotalAmount   pgtype.Numeric     `json:"total_amount"`
	PaidAmount    pgtype.Numeric     `json:"paid_amount"`
	ChangeAmount  pgtype.Numeric     `json:"change_amount"`
	PaymentMethod pgtype.Text        `json:"payment_method"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	CashierName   pgtype.Text        `json:"cashier_name"`
}

func (q *Queries) GetSaleByID(ctx context.Context, id int32) (GetSaleByIDRow, error) {
	row := q.db.QueryRow(ctx, getSaleByID, id)
	var i GetSaleByIDRow
	err := row.Scan(
		&i.ID,
		&i.InvoiceNo,
		&i.UserID,
		&i.TotalAmount,
		&i.PaidAmount,
		&i.ChangeAmount,
		&i.PaymentMethod,
		&i.CreatedAt,
		&i.CashierName,
	)
	return i, err
}

const getSaleByInvoice = `-- name: GetSaleByInvoice :one
SELECT s.id, s.invoice_no, s.user_id, s.total_amount, s.paid_amount, s.change_amount, s.payment_method, s.created_at, u.username as cashier_name
FROM sales s
LEFT JOIN users u ON s.user_id = u.id
WHERE s.invoice_no = $1 LIMIT 1
`

type GetSaleByInvoiceRow struct {
	ID            int32              `json:"id"`
	InvoiceNo     string             `json:"invoice_no"`
	UserID        pgtype.Int4        `json:"user_id"`
	TotalAmount   pgtype.Numeric     `json:"total_amount"`
	PaidAmount    pgtype.Numeric     `json:"paid_amount"`
	ChangeAmount  pgtype.Numeric     `json:"change_amount"`
	PaymentMethod pgtype.Text        `json:"payment_method"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	CashierName   pgtype.Text        `json:"cashier_name"`
}

func (q *Queries) GetSaleByInvoice(ctx context.Context, invoiceNo string) (GetSaleByInvoiceRow, error) {
	row := q.db.QueryRow(ctx, getSaleByInvoice, invoiceNo)
	var i GetSaleByInvoiceRow
	err := row.Scan(
		&i.ID,
		&i.InvoiceNo,
		&i.UserID,
		&i.TotalAmount,
		&i.PaidAmount,
		&i.ChangeAmount,
		&i.PaymentMethod,
		&i.CreatedAt,
		&i.CashierName,
	)
	return i, err
}

const getSalesStats = `-- name: GetSalesStats :one
SELECT 
  COUNT(*) as total_sales,
  COALESCE(SUM(total_amount), 0) as total_revenue,
  COALESCE(AVG(total_amount), 0) as avg_sale_amount
FROM sales
WHERE created_at >= $1 AND created_at <= $2
`

type GetSalesStatsParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type GetSalesStatsRow struct {
	TotalSales    int64       `json:"total_sales"`
	TotalRevenue  interface{} `json:"total_revenue"`
	AvgSaleAmount interface{} `json:"avg_sale_amount"`
}

func (q *Queries) GetSalesStats(ctx context.Context, arg GetSalesStatsParams) (GetSalesStatsRow, error) {
	row := q.db.QueryRow(ctx, getSalesStats, arg.CreatedAt, arg.CreatedAt_2)
	var i GetSalesStatsRow
	err := row.Scan(&i.TotalSales, &i.TotalRevenue, &i.AvgSaleAmount)
	return i, err
}

const listSales = `-- name: ListSales :many
SELECT s.id, s.invoice_no, s.user_id, s.total_amount, s.paid_amount, s.change_amount, s.payment_method, s.created_at, u.username as cashier_name
FROM sales s
LEFT JOIN users u ON s.user_id = u.id
ORDER BY s.created_at DESC
LIMIT $1 OFFSET $2
`

type ListSalesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListSalesRow struct {
	ID            int32              `json:"id"`
	InvoiceNo     string             `json:"invoice_no"`
	UserID        pgtype.Int4        `json:"user_id"`
	TotalAmount   pgtype.Numeric     `json:"total_amount"`
	PaidAmount    pgtype.Numeric     `json:"paid_amount"`
	ChangeAmount  pgtype.Numeric     `json:"change_amount"`
	PaymentMethod pgtype.Text        `json:"payment_method"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	CashierName   pgtype.Text        `json:"cashier_name"`
}

func (q *Queries) ListSales(ctx context.Context, arg ListSalesParams) ([]ListSalesRow, error) {
	rows, err := q.db.Query(ctx, listSales, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSalesRow{}
	for rows.Next() {
		var i ListSalesRow
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNo,
			&i.UserID,
			&i.TotalAmount,
			&i.PaidAmount,
			&i.ChangeAmount,
			&i.PaymentMethod,
			&i.CreatedAt,
			&i.CashierName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSalesByDateRange = `-- name: ListSalesByDateRange :many
SELECT s.id, s.invoice_no, s.user_id, s.total_amount, s.paid_amount, s.change_amount, s.payment_method, s.created_at, u.username as cashier_name
FROM sales s
LEFT JOIN users u ON s.user_id = u.id
WHERE s.created_at >= $1 AND s.created_at <= $2
ORDER BY s.created_at DESC
`

type ListSalesByDateRangeParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type ListSalesByDateRangeRow struct {
	ID            int32              `json:"id"`
	InvoiceNo     string             `json:"invoice_no"`
	UserID        pgtype.Int4        `json:"user_id"`
	TotalAmount   pgtype.Numeric     `json:"total_amount"`
	PaidAmount    pgtype.Numeric     `json:"paid_amount"`
	ChangeAmount  pgtype.Numeric     `json:"change_amount"`
	PaymentMethod pgtype.Text        `json:"payment_method"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	CashierName   pgtype.Text        `json:"cashier_name"`
}

func (q *Queries) ListSalesByDateRange(ctx context.Context, arg ListSalesByDateRangeParams) ([]ListSalesByDateRangeRow, error) {
	rows, err := q.db.Query(ctx, listSalesByDateRange, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSalesByDateRangeRow{}
	for rows.Next() {
		var i ListSalesByDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNo,
			&i.UserID,
			&i.TotalAmount,
			&i.PaidAmount,
			&i.ChangeAmount,
			&i.PaymentMethod,
			&i.CreatedAt,
			&i.CashierName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
